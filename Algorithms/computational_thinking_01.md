# Computational Thinking

## 프로그래밍과 논리/수학

### 논리와 증명

#### 논리

-   `Hard Logic` vs `Soft Logic`
-   `직관`은 논리적인 **느낌**을 주는 것
-   `직관`의 장점은 *익숙한 상황에서*  빠르다는 것
-   `직관`의 단점은 정확하지 않다는 것, 강한 착각을 일으킨다는 것

```
# 과자와 버스
"과자 몇개 먹었니?" vs. "버스 타려는데 천원 있니?"

- 두 질문은 같은 표현을 사용하지만, 하나는 정확한 개수, 다른 하나는 천원 이상이 있는지 물어보는 것
```

```
# 토플과 복권
"합격하려면 TOEFL 500 이상 혹은 TOEIC 600 이상 필요" vs. "복권에 당첨되면 자동차 혹은 천만원 드립니다"

- 두 명제는 같은 표현을 사용하지만 하나는 inclusive or, 다른 하나는 exclusive or
```

-   일상 생활에서는 `Soft Logic`이 빠르기 때문에 유용
-   프로그래밍은 `Hard Logic`

-   `p이면 q이다`에서 `p`가 **거짓**일 경우, `명제`는 항상 **참**
-   `p이면 q이다`에서 `q`가 **참**인 경우, `명제`는 항상 **참**
-   `p이면 q이다`라는 `명제`가 **거짓**이기 위해서는 항상 `p`는 **참**, `q`는 **거짓**

#### 증명

-   `증명`은 정확한 명제식으로 표현할 수 있는 것이라야 함
-   `증명`에 대한 수많은 오해가 `p→q`를 `p↔q`와 혼동하는 것에서 일어남

```
# 수학적 귀납법
기본형: p(1)이 참이고, p(n)→p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해 참이다.

강한 형태: p(1)이 참이고, p(1)∧p(2)∧...∧p(n)→p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해 참이다.
```

```
# 다음 함수가 1부터 x까지의 합을 계산함을 증명해 보자.

int sum(int x)
{
	if (x <= 0) return 0;
	return x + sum(x-1);
}

증명이 가능한 명제: "sum(x)가 리턴하는 값은 1+2+...+x의 값과 항상 같다"
```

-   `sum(x-1)`을 블랙박스로 생각하는 것이 이해에 도움을 주는 경우가 많다

```
# 버블 소트의 증명

명제: "A[1]<A[2]<...<A[n]"
```



### 수와 표현

-   컴퓨터는 `0/1`을 표현할 수 있는 `비트`를 모아 수를 표현함
-   k개의 비트를 사용하면 `0 ~ 2^(k) - 1`까지 표현이 가능
-   어떤 값 n을 표현하기 위해 비트 k개가 필요할 때, `2^(k) - 1 >= n`이 성립
-   같은 의미로, `k >= log(n+1)` → 약 `log n`비트가 필요
-   즉, `log n`이란
    -   n을 표현하는데 필요한 비트의 수
    -   1에서 시작해 계속 두 배씩 늘릴때, 몇 번 하면 n이 되느냐의 답
    -   n을 계속 2로 나눌 때 몇 번 시행하면 거의 1에 도달하는지에 대한 답
-   `32bit 컴퓨터`의 `주소 공간`은 `2^(32) = 약 40억 개`

```
- n + (n/2 + n/2) + (n/4 + n/4 + n/4 + n/4) + (n/8 + n/8 + ...) + ... + (1 + 1 + ...) = nlogn

- n + n/2 + n/4 + ... + 1 ≒ 2n

- 위 두 식의 항의 개수는 logn개
```

